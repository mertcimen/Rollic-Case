// Developed by Tom Kail at Inkle
// Released under the MIT License as held at https://opensource.org/licenses/MIT

// Must be placed within a folder named "Editor"
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

namespace BaseSystems.Scripts.Utilities.SerializedScriptableObject.Editor
{
	/// <summary>
	/// Extends how ScriptableObject object references are displayed in the inspector
	/// Shows you all values under the object reference
	/// Also provides a button to create a new ScriptableObject if the property is null.
	/// </summary>
	[CustomPropertyDrawer(typeof(SerializedScriptableObject), true)]
	public class ExtendedScriptableObjectDrawer : PropertyDrawer
	{
		private static readonly List<string> ignoreClassFullNames = new List<string> { "TMPro.TMP_FontAsset" };

		private const int BUTTON_WIDTH = 66;

		public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
		{
			var totalHeight = EditorGUIUtility.singleLineHeight;
			if (property.objectReferenceValue == null || !AreAnySubPropertiesVisible(property))
				return totalHeight;
			if (!property.isExpanded) 
				return totalHeight;
			if (property.objectReferenceValue is not SerializedScriptableObject data)
				return EditorGUIUtility.singleLineHeight;
			
			var serializedObject = new SerializedObject(data);
			var prop = serializedObject.GetIterator();
			if (prop.NextVisible(true))
			{
				do
				{
					if (prop.name == "m_Script") continue;
					var subProp = serializedObject.FindProperty(prop.name);
					var height = EditorGUI.GetPropertyHeight(subProp, null, true) + EditorGUIUtility.standardVerticalSpacing;
					totalHeight += height;
				} while (prop.NextVisible(false));
			}

			// Add a tiny bit of height if open for the background
			totalHeight += EditorGUIUtility.standardVerticalSpacing;
			serializedObject.Dispose();

			return totalHeight;
		}

		public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
		{
			EditorGUI.BeginProperty(position, label, property);
			var type = GetFieldType();

			if (type is null || ignoreClassFullNames.Contains(type.FullName))
			{
				EditorGUI.PropertyField(position, property, label);
				EditorGUI.EndProperty();
				return;
			}

			SerializedScriptableObject propertySO = null;
			if (!property.hasMultipleDifferentValues && property.serializedObject.targetObject != null && property.serializedObject.targetObject is SerializedScriptableObject targetObject)
			{
				propertySO = targetObject;
			}

			var guiContent = new GUIContent(property.displayName);
			var foldoutRect = new Rect(position.x, position.y, EditorGUIUtility.labelWidth, EditorGUIUtility.singleLineHeight);
			if (property.objectReferenceValue != null && AreAnySubPropertiesVisible(property))
			{
				property.isExpanded = EditorGUI.Foldout(foldoutRect, property.isExpanded, guiContent, true);
			}
			else
			{
				// So yeah having a foldout look like a label is a weird hack
				// but both code paths seem to need to be a foldout or 
				// the object field control goes weird when the codepath changes.
				// I guess because foldout is an interactable control of its own and throws off the controlID?
				foldoutRect.x += 12;
				EditorGUI.Foldout(foldoutRect, property.isExpanded, guiContent, true, EditorStyles.label);
			}

			var indentedPosition = EditorGUI.IndentedRect(position);
			var indentOffset = indentedPosition.x - position.x;
			var propertyRect = new Rect(position.x + (EditorGUIUtility.labelWidth - indentOffset), position.y, position.width - (EditorGUIUtility.labelWidth - indentOffset),
				EditorGUIUtility.singleLineHeight);

			if (propertySO is not null || property.objectReferenceValue is null)
			{
				propertyRect.width -= BUTTON_WIDTH;
			}

			EditorGUI.ObjectField(propertyRect, property, type, GUIContent.none);
			if (GUI.changed) property.serializedObject.ApplyModifiedProperties();

			var buttonRect = new Rect(position.x + position.width - BUTTON_WIDTH, position.y, BUTTON_WIDTH, EditorGUIUtility.singleLineHeight);

			if (property.propertyType == SerializedPropertyType.ObjectReference && property.objectReferenceValue is not null)
			{
				var data = (SerializedScriptableObject)property.objectReferenceValue;

				if (property.isExpanded)
				{
					// Draw a background that shows us clearly which fields are part of the ScriptableObject
					GUI.Box(
						new Rect(0, position.y + EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing - 1, Screen.width,
							position.height - EditorGUIUtility.singleLineHeight - EditorGUIUtility.standardVerticalSpacing), "");

					EditorGUI.indentLevel++;
					var serializedObject = new SerializedObject(data);

					// Iterate over all the values and draw them
					var prop = serializedObject.GetIterator();
					float y = position.y + EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;
					if (prop.NextVisible(true))
					{
						do
						{
							// Don't bother drawing the class file
							if (prop.name == "m_Script") continue;
							var height = EditorGUI.GetPropertyHeight(prop, new GUIContent(prop.displayName), true);
							EditorGUI.PropertyField(new Rect(position.x, y, position.width - BUTTON_WIDTH, height), prop, true);
							y += height + EditorGUIUtility.standardVerticalSpacing;
						} while (prop.NextVisible(false));
					}

					if (GUI.changed)
						serializedObject.ApplyModifiedProperties();
					serializedObject.Dispose();
					EditorGUI.indentLevel--;
				}
			}
			else
			{
				if (GUI.Button(buttonRect, "Create"))
				{
					string selectedAssetPath = "Assets";
					if (property.serializedObject.targetObject is MonoBehaviour behaviour)
					{
						var ms = MonoScript.FromMonoBehaviour(behaviour);
						selectedAssetPath = System.IO.Path.GetDirectoryName(AssetDatabase.GetAssetPath(ms));
					}

					property.objectReferenceValue = CreateAssetWithSavePrompt(type, selectedAssetPath);
				}
			}

			property.serializedObject.ApplyModifiedProperties();
			EditorGUI.EndProperty();
		}

		public static T _GUILayout<T>(string label, T objectReferenceValue, ref bool isExpanded) where T : SerializedScriptableObject
		{
			return _GUILayout<T>(new GUIContent(label), objectReferenceValue, ref isExpanded);
		}

		public static T _GUILayout<T>(GUIContent label, T objectReferenceValue, ref bool isExpanded) where T : SerializedScriptableObject
		{
			var position = EditorGUILayout.BeginVertical();

			var propertyRect = Rect.zero;
			var foldoutRect = new Rect(position.x, position.y, EditorGUIUtility.labelWidth, EditorGUIUtility.singleLineHeight);
			if (objectReferenceValue != null)
			{
				isExpanded = EditorGUI.Foldout(foldoutRect, isExpanded, label, true);

				var indentedPosition = EditorGUI.IndentedRect(position);
				var indentOffset = indentedPosition.x - position.x;
				propertyRect = new Rect(position.x + EditorGUIUtility.labelWidth - indentOffset, position.y, position.width - EditorGUIUtility.labelWidth - indentOffset,
					EditorGUIUtility.singleLineHeight);
			}
			else
			{
				// So yeah having a foldout look like a label is a weird hack 
				// but both code paths seem to need to be a foldout or 
				// the object field control goes weird when the codepath changes.
				// I guess because foldout is an interactable control of its own and throws off the controlID?
				foldoutRect.x += 12;
				EditorGUI.Foldout(foldoutRect, isExpanded, label, true, EditorStyles.label);

				var indentedPosition = EditorGUI.IndentedRect(position);
				var indentOffset = indentedPosition.x - position.x;
				propertyRect = new Rect(position.x + EditorGUIUtility.labelWidth - indentOffset, position.y, position.width - EditorGUIUtility.labelWidth - indentOffset - 60,
					EditorGUIUtility.singleLineHeight);
			}

			EditorGUILayout.BeginHorizontal();
			objectReferenceValue = EditorGUILayout.ObjectField(new GUIContent(" "), objectReferenceValue, typeof(T), false) as T;

			if (objectReferenceValue != null)
			{
				EditorGUILayout.EndHorizontal();
				if (isExpanded)
				{
					DrawScriptableObjectChildFields(objectReferenceValue);
				}
			}
			else
			{
				if (GUILayout.Button("Create", GUILayout.Width(BUTTON_WIDTH)))
				{
					string selectedAssetPath = "Assets";
					var newAsset = CreateAssetWithSavePrompt(typeof(T), selectedAssetPath);
					if (newAsset != null)
					{
						objectReferenceValue = (T)newAsset;
					}
				}

				EditorGUILayout.EndHorizontal();
			}

			EditorGUILayout.EndVertical();
			return objectReferenceValue;
		}

		static void DrawScriptableObjectChildFields<T>(T objectReferenceValue) where T : SerializedScriptableObject
		{
			// Draw a background that shows us clearly which fields are part of the ScriptableObject
			EditorGUI.indentLevel++;
			EditorGUILayout.BeginVertical(GUI.skin.box);

			var serializedObject = new SerializedObject(objectReferenceValue);
			// Iterate over all the values and draw them
			SerializedProperty prop = serializedObject.GetIterator();
			if (prop.NextVisible(true))
			{
				do
				{
					// Don't bother drawing the class file
					if (prop.name == "m_Script") continue;
					EditorGUILayout.PropertyField(prop, true);
				} while (prop.NextVisible(false));
			}

			if (GUI.changed)
				serializedObject.ApplyModifiedProperties();
			serializedObject.Dispose();
			EditorGUILayout.EndVertical();
			EditorGUI.indentLevel--;
		}

		public static T DrawScriptableObjectField<T>(GUIContent label, T objectReferenceValue, ref bool isExpanded) where T : SerializedScriptableObject
		{
			var position = EditorGUILayout.BeginVertical();

			var propertyRect = Rect.zero;
			var guiContent = label;
			var foldoutRect = new Rect(position.x, position.y, EditorGUIUtility.labelWidth, EditorGUIUtility.singleLineHeight);
			if (objectReferenceValue != null)
			{
				isExpanded = EditorGUI.Foldout(foldoutRect, isExpanded, guiContent, true);

				var indentedPosition = EditorGUI.IndentedRect(position);
				var indentOffset = indentedPosition.x - position.x;
				propertyRect = new Rect(position.x + EditorGUIUtility.labelWidth - indentOffset, position.y, position.width - EditorGUIUtility.labelWidth - indentOffset,
					EditorGUIUtility.singleLineHeight);
			}
			else
			{
				// So yeah having a foldout look like a label is a weird hack 
				// but both code paths seem to need to be a foldout or 
				// the object field control goes weird when the codepath changes.
				// I guess because foldout is an interactable control of its own and throws off the controlID?
				foldoutRect.x += 12;
				EditorGUI.Foldout(foldoutRect, isExpanded, guiContent, true, EditorStyles.label);

				var indentedPosition = EditorGUI.IndentedRect(position);
				var indentOffset = indentedPosition.x - position.x;
				propertyRect = new Rect(position.x + EditorGUIUtility.labelWidth - indentOffset, position.y, position.width - EditorGUIUtility.labelWidth - indentOffset - 60,
					EditorGUIUtility.singleLineHeight);
			}

			EditorGUILayout.BeginHorizontal();
			objectReferenceValue = EditorGUILayout.ObjectField(new GUIContent(" "), objectReferenceValue, typeof(T), false) as T;

			if (objectReferenceValue != null)
			{
				EditorGUILayout.EndHorizontal();
				if (isExpanded)
				{
				}
			}
			else
			{
				if (GUILayout.Button("Create", GUILayout.Width(BUTTON_WIDTH)))
				{
					var selectedAssetPath = "Assets";
					var newAsset = CreateAssetWithSavePrompt(typeof(T), selectedAssetPath);
					if (newAsset != null)
					{
						objectReferenceValue = (T)newAsset;
					}
				}

				EditorGUILayout.EndHorizontal();
			}

			EditorGUILayout.EndVertical();
			return objectReferenceValue;
		}

		// Creates a new ScriptableObject via the default Save File panel
		private static SerializedScriptableObject CreateAssetWithSavePrompt(Type type, string path)
		{
			path = EditorUtility.SaveFilePanelInProject("Save ScriptableObject", type.Name + ".asset", "asset", "Enter a file name for the ScriptableObject.", path);
			if (path == "") return null;
			var asset = (SerializedScriptableObject)ScriptableObject.CreateInstance(type);
			AssetDatabase.CreateAsset(asset, path);
			AssetDatabase.SaveAssets();
			AssetDatabase.Refresh();
			AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);
			EditorGUIUtility.PingObject(asset);
			return asset;
		}

		private Type GetFieldType()
		{
			var type = fieldInfo.FieldType;
			if (type.IsArray) type = type.GetElementType();
			else if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>)) type = type.GetGenericArguments()[0];
			return type;
		}

		private static bool AreAnySubPropertiesVisible(SerializedProperty property)
		{
			var data = (SerializedScriptableObject)property.objectReferenceValue;
			var serializedObject = new SerializedObject(data);
			var prop = serializedObject.GetIterator();
			while (prop.NextVisible(true))
			{
				if (prop.name == "m_Script") continue;
				return true; //if there is any visible property other than m_script
			}

			serializedObject.Dispose();
			return false;
		}
	}
}